# app/main_app.py
# Microsoft Graph App-Only Service â€” FastAPI
# -------------------------------------------------------------
# Uses client credentials (TENANT_ID, CLIENT_ID, CLIENT_SECRET)
# Exposes endpoints for: mail, calendar events (Teams), online
# meetings, attendance, Teams channels/messages (RSC), and
# discovery helpers for Team/Channel/Meetings/Events.
# -------------------------------------------------------------

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import os, time, json, requests

app = FastAPI(title="Graph App-Only Service", version="1.0.0")

GRAPH_BASE = "https://graph.microsoft.com/v1.0"

TENANT_ID = os.getenv("TENANT_ID", "")
CLIENT_ID = os.getenv("CLIENT_ID", "")
CLIENT_SECRET = os.getenv("CLIENT_SECRET", "")

if not (TENANT_ID and CLIENT_ID and CLIENT_SECRET):
    print("[WARN] TENANT_ID/CLIENT_ID/CLIENT_SECRET not set at import time")

# --------------------------- OAuth (client credentials) -----------------------

TOKEN_CACHE_PATH = "/tmp/msal_token_cache.bin"

def get_app_token() -> str:
    """
    Acquire an app-only token via client credentials for scope: https://graph.microsoft.com/.default
    Simple file cache used to avoid fetching a token on every request.
    """
    # Read cache
    if os.path.exists(TOKEN_CACHE_PATH):
        try:
            with open(TOKEN_CACHE_PATH, "r") as f:
                data = json.load(f)
            if data.get("expires_at", 0) > int(time.time()) + 60:
                return data["access_token"]
        except Exception:
            pass

    token_url = f"https://login.microsoftonline.com/{TENANT_ID}/oauth2/v2.0/token"
    resp = requests.post(
        token_url,
        data={
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
            "scope": "https://graph.microsoft.com/.default",
            "grant_type": "client_credentials",
        },
        timeout=30,
    )
    if not resp.ok:
        raise RuntimeError(f"Failed to obtain token: {resp.status_code} {resp.text}")
    tok = resp.json()
    access_token = tok["access_token"]
    # Write cache
    try:
        with open(TOKEN_CACHE_PATH, "w") as f:
            json.dump(
                {
                    "access_token": access_token,
                    "expires_at": int(time.time()) + int(tok.get("expires_in", 3599)),
                },
                f,
            )
    except Exception:
        pass
    return access_token


def graph_request(
    method: str,
    path: str,
    params: Dict[str, Any] | None = None,
    json_body: Dict[str, Any] | None = None,
) -> Dict[str, Any]:
    """
    Call Graph with app token. `path` must start with '/' (e.g., '/users').
    Raises HTTPException with structured detail on non-2xx.
    """
    token = get_app_token()
    url = GRAPH_BASE + path
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    resp = requests.request(
        method, url, headers=headers, params=params, json=json_body, timeout=60
    )
    if not resp.ok:
        detail_resp: Any
        try:
            detail_resp = resp.json()
        except Exception:
            detail_resp = resp.text
        # If params were used, show the fully prepared URL for debugging
        full_url = url
        try:
            full_url = requests.Request(method, url, params=params).prepare().url
        except Exception:
            pass
        raise HTTPException(
            status_code=resp.status_code,
            detail={"status": resp.status_code, "url": full_url, "response": detail_resp},
        )
    return resp.json() if resp.text else {}

# --------------------------- Models ------------------------------------------

class EmailAddress(BaseModel):
    address: str
    name: Optional[str] = None

class SendMailBody(BaseModel):
    from_user_id: str = Field(..., description="User UPN or id to send as")
    to: List[EmailAddress]
    subject: str
    html_body: str

class EventAttendee(BaseModel):
    email: str
    name: Optional[str] = None
    type: str = "required"  # 'required' or 'optional'

class CreateEventBody(BaseModel):
    user_id: str
    subject: str
    body_html: Optional[str] = ""
    start_iso: str
    end_iso: str
    timezone: Optional[str] = "UTC"
    attendees: List[EventAttendee] = []
    is_online_meeting: bool = True

class CreateOnlineMeetingBody(BaseModel):
    user_id: str
    subject: str
    start_iso: str
    end_iso: str

class FollowUpBody(BaseModel):
    organizer_user_id: str
    online_meeting_id: str
    start_iso: str
    end_iso: str
    subject: str = "Follow-up Meeting"

class CreateChannelBody(BaseModel):
    team_id: str
    display_name: str
    description: Optional[str] = ""

class PostChannelMessageBody(BaseModel):
    team_id: str
    channel_id: str
    content: str  # HTML supported

# --------------------------- Health ------------------------------------------

@app.get("/healthz")
def healthz():
    return {"status": "ok", "ts": int(time.time())}

# --------------------------- Mail --------------------------------------------

@app.post("/mail/send")
def send_mail(body: SendMailBody):
    """
    Send mail AS a specific user.
    Requires Mail.Send (Application). Scope access with Exchange RBAC for Applications or legacy ApplicationAccessPolicy.
    """
    payload = {
        "message": {
            "subject": body.subject,
            "body": {"contentType": "HTML", "content": body.html_body},
            "toRecipients": [{"emailAddress": e.dict()} for e in body.to],
        },
        "saveToSentItems": "true",
    }
    result = graph_request("POST", f"/users/{body.from_user_id}/sendMail", json_body=payload)
    return {"ok": True, "result": result}

# --------------------------- Teams / Channels (RSC-required) ------------------

@app.post("/teams/channels")
def create_channel(body: CreateChannelBody):
    """
    Create a standard channel in a team.
    Requires RSC permission Channel.Create.Group and the app installed in that team.
    """
    payload = {
        "displayName": body.display_name,
        "description": body.description or "",
        "membershipType": "standard",
    }
    result = graph_request("POST", f"/teams/{body.team_id}/channels", json_body=payload)
    return {"ok": True, "channel": result}

@app.post("/teams/channels/message")
def post_channel_message(body: PostChannelMessageBody):
    """
    Post a message in a team channel.
    Requires RSC permission ChannelMessage.Send.Group and the app installed in that team.
    """
    payload = {"body": {"contentType": "html", "content": body.content}}
    result = graph_request(
        "POST", f"/teams/{body.team_id}/channels/{body.channel_id}/messages", json_body=payload
    )
    return {"ok": True, "message": result}

# --------------------------- Calendar (Events with Teams) ---------------------

@app.post("/events")
def create_event(body: CreateEventBody):
    """
    Create a calendar event for a user (optionally a Teams meeting).
    Requires Calendars.ReadWrite (Application).
    """
    attendees = [
        {
            "emailAddress": {"address": a.email, "name": a.name or a.email},
            "type": "required" if a.type.lower() == "required" else "optional",
        }
        for a in body.attendees
    ]
    payload = {
        "subject": body.subject,
        "body": {"contentType": "HTML", "content": body.body_html or ""},
        "start": {"dateTime": body.start_iso, "timeZone": body.timezone},
        "end": {"dateTime": body.end_iso, "timeZone": body.timezone},
        "attendees": attendees,
        "isOnlineMeeting": bool(body.is_online_meeting),
        "onlineMeetingProvider": "teamsForBusiness",
    }
    created = graph_request("POST", f"/users/{body.user_id}/events", json_body=payload)

    # Re-fetch with $expand=onlineMeeting to surface joinUrl
    ev_id = created.get("id")
    if ev_id:
        created = graph_request(
            "GET",
            f"/users/{body.user_id}/events/{ev_id}",
            params={"$expand": "onlineMeeting", "$select": "id,subject,onlineMeeting"},
        )
    return {"ok": True, "event": created}

# --------------------------- Online Meetings (Cloud Comms AAP) ---------------

@app.post("/online-meetings")
def create_online_meeting(body: CreateOnlineMeetingBody):
    """
    Create an Online Meeting (Teams) for a user.
    Requires OnlineMeetings.ReadWrite.All (Application) AND a Cloud Comms Application Access Policy (AAP) for the organizer.
    """
    payload = {"subject": body.subject, "startDateTime": body.start_iso, "endDateTime": body.end_iso}
    result = graph_request("POST", f"/users/{body.user_id}/onlineMeetings", json_body=payload)
    return {"ok": True, "onlineMeeting": result}

@app.get("/online-meetings/{organizer_user_id}/{meeting_id}/attendance")
def get_attendance(organizer_user_id: str, meeting_id: str):
    """
    Read attendance report for an online meeting.
    Requires OnlineMeetingArtifact.Read.All and the same AAP as creation.
    """
    result = graph_request(
        "GET",
        f"/users/{organizer_user_id}/onlineMeetings/{meeting_id}/attendanceReports",
        params={"$expand": "attendanceRecords"},
    )
    return {"ok": True, "attendanceReports": result.get("value", [])}

@app.post("/online-meetings/followup")
def schedule_followup(body: FollowUpBody):
    """
    Create a follow-up event using attendees from an existing online meeting.
    """
    att = graph_request(
        "GET",
        f"/users/{body.organizer_user_id}/onlineMeetings/{body.online_meeting_id}/attendanceReports",
        params={"$expand": "attendanceRecords"},
    )
    emails: list[str] = []
    seen = set()
    for report in att.get("value", []):
        for rec in report.get("attendanceRecords", []):
            mail = (rec.get("emailAddress") or "").strip()
            if mail and mail.lower() not in seen:
                seen.add(mail.lower())
                emails.append(mail)

    # Build CreateEventBody and reuse create_event()
    payload = CreateEventBody(
        user_id=body.organizer_user_id,
        subject=body.subject,
        start_iso=body.start_iso,
        end_iso=body.end_iso,
        attendees=[EventAttendee(email=e) for e in emails],
        is_online_meeting=True,
        timezone="UTC",
        body_html="Auto-created follow-up from attendance list",
    )
    return create_event(payload)

# --------------------------- DISCOVERY HELPERS -------------------------------

@app.get("/teams")
def list_teams(top: int = 50):
    """List all Teams (groupId == Team ID)."""
    result = graph_request(
        "GET",
        "/groups",
        params={
            "$filter": "resourceProvisioningOptions/Any(x:x eq 'Team')",
            "$select": "id,displayName",
            "$top": top,
        },
    )
    return {"ok": True, "teams": result.get("value", [])}

@app.get("/teams/{team_id}/channels")
def list_channels(team_id: str, top: int = 50):
    """List channels for a given Team."""
    result = graph_request(
        "GET",
        f"/teams/{team_id}/channels",
        params={"$select": "id,displayName,description", "$top": top},
    )
    return {"ok": True, "channels": result.get("value", [])}

@app.get("/users/{user_id}/meetings")
def list_online_meetings(user_id: str, start: str, end: str, top: int = 50):
    """
    List online meetings for a user in a UTC window (ISO 8601 with 'Z').
    Requires OnlineMeetings.ReadWrite.All + AAP for that user.
    """
    result = graph_request(
        "GET",
        f"/users/{user_id}/onlineMeetings",
        params={"startDateTime": start, "endDateTime": end, "$top": top},
    )
    return {"ok": True, "meetings": result.get("value", [])}

@app.get("/users/{user_id}/events")
def list_calendar_events(user_id: str, start: str, end: str, online_only: bool = True, top: int = 50):
    """
    List calendar events for a user, optionally only Teams meetings.
    Requires Calendars.Read or Calendars.ReadWrite (Application).
    """
    filt = f"start/dateTime ge '{start}' and end/dateTime le '{end}'"
    if online_only:
        filt = f"isOnlineMeeting eq true and {filt}"
    result = graph_request(
        "GET",
        f"/users/{user_id}/events",
        params={
            "$filter": filt,
            "$expand": "onlineMeeting",
            "$select": "id,subject,start,end,isOnlineMeeting,onlineMeeting,webLink",
            "$top": top,
        },
    )
    return {"ok": True, "events": result.get("value", [])}
