# app/main_app.py
# Microsoft Graph - FastAPI service
# Modes:
#   - Application permissions (client credentials)  -> mail/events/teams
#   - Delegated permissions via MSAL Device Code    -> /me, 1:1 chat, etc.
#
# Env:
#   TENANT_ID      = <GUID> or 'organizations'
#   CLIENT_ID      = App (client) ID
#   CLIENT_SECRET  = Client secret (Value)  [required for APP-ONLY calls]
#   AUTH_TENANT    = <tenantId or 'organizations'>  (optional; defaults to TENANT_ID)
#
# Azure prerequisites for delegated (device code):
#   - App registration > Authentication > "Allow public client flows" = Yes
#   - Delegated Graph perms (grant admin consent): User.Read, Chat.ReadWrite,
#     ChannelMessage.Send (if needed), Mail.Send (if needed), Calendars.ReadWrite (if needed),
#     openid, profile, offline_access

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
import os, time, json, urllib.parse, requests
from threading import Thread

from msal import PublicClientApplication, SerializableTokenCache

app = FastAPI(title="Graph App (App + MSAL DeviceCode Delegated)", version="4.1.0")

GRAPH = "https://graph.microsoft.com/v1.0"

TENANT_ID = os.getenv("TENANT_ID", "")
CLIENT_ID = os.getenv("CLIENT_ID", "")
CLIENT_SECRET = os.getenv("CLIENT_SECRET", "")
AUTH_TENANT = os.getenv("AUTH_TENANT", TENANT_ID or "organizations")

if not CLIENT_ID:
    raise RuntimeError("CLIENT_ID env var is required")

# ---------------------------------------------------------------------------
# MSAL (Delegated) - device code flow with persistent cache
# ---------------------------------------------------------------------------
DELEGATED_SCOPES = [
    "User.Read",
    "Chat.ReadWrite",
    "ChannelMessage.Send",
    "Mail.Send",
    "Calendars.ReadWrite",
    "openid",
    "profile",
    "offline_access",
]

CACHE_PATH = "token-cache.json"
token_cache = SerializableTokenCache()
try:
    with open(CACHE_PATH, "r") as f:
        token_cache.deserialize(f.read())
except FileNotFoundError:
    pass

def save_cache():
    if token_cache.has_state_changed:
        with open(CACHE_PATH, "w") as f:
            f.write(token_cache.serialize())

public_app = PublicClientApplication(
    CLIENT_ID,
    authority=f"https://login.microsoftonline.com/{AUTH_TENANT}",
    token_cache=token_cache,
)

def get_user_token() -> str:
    """
    Returns a valid delegated access token from the MSAL cache (silent refresh).
    Requires that one of the device-login flows has been completed at least once.
    """
    accounts = public_app.get_accounts()
    if accounts:
        result = public_app.acquire_token_silent(DELEGATED_SCOPES, account=accounts[0])
        if result and "access_token" in result:
            return result["access_token"]
    raise HTTPException(status_code=401, detail="No delegated tokenâ€”run POST /auth/device-login or the start/complete flow")

def graph_delegated_request(method: str, path: str, params=None, json_body=None, raw_data: str = None):
    """
    If raw_data is provided (JSON string), it's sent as-is; use this when you need exact keys like 'user@odata.bind'.
    """
    url = GRAPH + path
    headers = {"Authorization": f"Bearer {get_user_token()}", "Content-Type": "application/json"}
    r = requests.request(
        method, url, headers=headers, params=params,
        json=None if raw_data is not None else json_body,
        data=raw_data, timeout=60
    )
    if not r.ok:
        try:
            payload = r.json()
        except Exception:
            payload = r.text
        full = requests.Request(method, url, params=params).prepare().url
        raise HTTPException(status_code=r.status_code, detail={"url": full, "response": payload})
    return r.json() if r.text else {}

# Optional: non-blocking device flow helpers
LAST_FLOW: Dict[str, Any] = {}
LOGIN_THREAD: Thread = None
LOGIN_RESULT: Dict[str, Any] = None

# ---------------------------------------------------------------------------
# App-only token (client credentials) with tiny file cache
# ---------------------------------------------------------------------------
APP_TOKEN_CACHE = "/tmp/app_token.cache"

def get_app_token() -> str:
    """Client credentials token for Graph (.default)."""
    if os.path.exists(APP_TOKEN_CACHE):
        try:
            data = json.load(open(APP_TOKEN_CACHE))
            if data.get("exp", 0) > int(time.time()) + 60:
                return data["access_token"]
        except Exception:
            pass

    tenant = TENANT_ID or "organizations"
    token_url = f"https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token"
    resp = requests.post(
        token_url,
        data={
            "client_id": CLIENT_ID,
            "client_secret": CLIENT_SECRET,
            "scope": "https://graph.microsoft.com/.default",
            "grant_type": "client_credentials",
        },
        timeout=30,
    )
    if not resp.ok:
        raise RuntimeError(f"app token error: {resp.status_code} {resp.text}")
    tok = resp.json()
    json.dump({"access_token": tok["access_token"], "exp": int(time.time()) + int(tok.get("expires_in", 3600))}, open(APP_TOKEN_CACHE, "w"))
    return tok["access_token"]

def graph_app_request(method: str, path: str, params=None, json_body=None):
    url = GRAPH + path
    headers = {"Authorization": f"Bearer {get_app_token()}", "Content-Type": "application/json"}
    r = requests.request(method, url, headers=headers, params=params, json=json_body, timeout=60)
    if not r.ok:
        try:
            payload = r.json()
        except Exception:
            payload = r.text
        full = requests.Request(method, url, params=params).prepare().url
        raise HTTPException(status_code=r.status_code, detail={"url": full, "response": payload})
    return r.json() if r.text else {}

# ---------------------------------------------------------------------------
# MODELS
# ---------------------------------------------------------------------------
class EmailAddress(BaseModel):
    address: str
    name: Optional[str] = None

class SendMailBody(BaseModel):
    from_user_id: str
    to: List[EmailAddress]
    subject: str
    html_body: str

class CreateEventBody(BaseModel):
    user_id: str
    subject: str
    start_iso: str
    end_iso: str
    timezone: Optional[str] = "UTC"
    body_html: Optional[str] = ""
    attendees: List[EmailAddress] = []
    is_online_meeting: bool = True

class OnlineMeetingBody(BaseModel):
    user_id: str
    subject: str
    start_iso: str
    end_iso: str

class PostChannelMessageBody(BaseModel):
    team_id: str
    channel_id: str
    content: str

class ChatToUserBody(BaseModel):
    to_upn: str = Field(..., description="Recipient UPN/email")
    message: str

# ---------------------------------------------------------------------------
# HEALTH
# ---------------------------------------------------------------------------
@app.get("/healthz")
def healthz():
    return {"ok": True, "time": int(time.time())}

# ---------------------------------------------------------------------------
# AUTH (Delegated via MSAL Device Code)
# ---------------------------------------------------------------------------
@app.get("/auth/status")
def auth_status():
    accounts = [a.get("username") for a in public_app.get_accounts()]
    return {"ok": True, "accounts": accounts, "cache": os.path.abspath(CACHE_PATH)}

# Blocking (one-call) device login
@app.post("/auth/device-login")
def device_login():
    flow = public_app.initiate_device_flow(scopes=DELEGATED_SCOPES)
    if "user_code" not in flow:
        # surface MSAL error (e.g., public client disabled, bad scopes)
        raise HTTPException(status_code=400, detail=flow)
    try:
        result = public_app.acquire_token_by_device_flow(flow)  # blocks until user completes
        save_cache()
    except Exception as ex:
        raise HTTPException(status_code=500, detail=str(ex))

    if "access_token" not in result:
        raise HTTPException(status_code=400, detail=result)

    return {
        "ok": True,
        "account": result.get("id_token_claims"),
        "scopes": result.get("scope"),
        "note": "Tokens cached; delegated calls will use silent refresh."
    }

# Non-blocking (two-step) device login
@app.post("/auth/device-start")
def device_start():
    global LAST_FLOW, LOGIN_THREAD, LOGIN_RESULT
    LOGIN_RESULT = None
    flow = public_app.initiate_device_flow(scopes=DELEGATED_SCOPES)
    if "user_code" not in flow:
        raise HTTPException(status_code=400, detail=flow)
    LAST_FLOW = flow
    # Print to server logs for convenience
    print(flow.get("message"))
    return {
        "ok": True,
        "user_code": flow["user_code"],
        "verification_uri": flow["verification_uri"],
        "message": flow["message"],
        "expires_in": flow.get("expires_in", 900),
        "interval": flow.get("interval", 5),
        "note": "Open the URL, enter the code, then POST /auth/device-complete and poll /auth/device-status."
    }

def _blocking_login():
    global LOGIN_RESULT
    try:
        LOGIN_RESULT = public_app.acquire_token_by_device_flow(LAST_FLOW)
        save_cache()
    except Exception as ex:
        LOGIN_RESULT = {"error": "exception", "error_description": str(ex)}

@app.post("/auth/device-complete")
def device_complete():
    global LOGIN_THREAD, LOGIN_RESULT
    if not LAST_FLOW:
        raise HTTPException(status_code=400, detail="No device flow in progress. Call /auth/device-start first.")
    if LOGIN_THREAD and LOGIN_THREAD.is_alive():
        return {"ok": False, "status": "pending"}
    LOGIN_RESULT = None
    LOGIN_THREAD = Thread(target=_blocking_login, daemon=True)
    LOGIN_THREAD.start()
    return {"ok": True, "status": "pending"}

@app.get("/auth/device-status")
def device_status():
    if LOGIN_RESULT is None:
        return {"ok": False, "status": "pending"}
    if "access_token" in LOGIN_RESULT:
        return {
            "ok": True,
            "status": "success",
            "account": LOGIN_RESULT.get("id_token_claims"),
            "scopes": LOGIN_RESULT.get("scope"),
            "note": "Tokens cached; delegated calls will work."
        }
    return {"ok": False, "status": "error", "detail": LOGIN_RESULT}

@app.post("/auth/logout")
def logout():
    for acct in public_app.get_accounts():
        public_app.remove_account(acct)
    save_cache()
    try:
        os.remove(CACHE_PATH)
    except FileNotFoundError:
        pass
    return {"ok": True, "message": "Delegated token cache cleared."}

# ---------------------------------------------------------------------------
# SIMPLE DELEGATED HELPERS
# ---------------------------------------------------------------------------
@app.get("/me")
def me():
    """Delegated: verify token & identity"""
    return graph_delegated_request("GET", "/me", params={"$select": "id,displayName,userPrincipalName"})

def get_user_id_by_upn_delegated(upn: str) -> str:
    u = graph_delegated_request("GET", f"/users/{urllib.parse.quote(upn)}", params={"$select": "id,userPrincipalName"})
    return u["id"]

@app.post("/chats/send")
def send_chat_to_user(body: ChatToUserBody):
    """
    Delegated: create (if needed) a 1:1 chat with to_upn and send 'message'.
    Requires delegated Chat.ReadWrite; some tenants may additionally require User.ReadBasic.All/User.Read.All for user lookup.
    Uses raw JSON to preserve 'user@odata.bind' keys.
    """
    target_id = get_user_id_by_upn_delegated(body.to_upn)

    chat_payload = {
        "chatType": "oneOnOne",
        "members": [
            {
                "@odata.type": "#microsoft.graph.aadUserConversationMember",
                "roles": ["owner"],
                "user@odata.bind": f"{GRAPH}/users/{target_id}"
            },
            {
                "@odata.type": "#microsoft.graph.aadUserConversationMember",
                "roles": ["owner"],
                "user@odata.bind": f"{GRAPH}/me"
            }
        ]
    }

    # Create chat with exact keys
    chat = graph_delegated_request("POST", "/chats", raw_data=json.dumps(chat_payload))
    chat_id = chat.get("id")
    if not chat_id:
        raise HTTPException(status_code=500, detail={"error": "Failed to create or resolve chat", "chat": chat})

    msg_payload = {"body": {"contentType": "html", "content": body.message}}
    msg = graph_delegated_request("POST", f"/chats/{chat_id}/messages", raw_data=json.dumps(msg_payload))
    return {"ok": True, "chatId": chat_id, "message": msg}

# ---------------------------------------------------------------------------
# APP-ONLY: Mail / Events / Meetings / Teams Channels
# ---------------------------------------------------------------------------
@app.post("/mail/send")
def send_mail(body: SendMailBody):
    """
    App-only sendMail as another user (requires Application Mail.Send with admin consent).
    """
    payload = {
        "message": {
            "subject": body.subject,
            "body": {"contentType": "HTML", "content": body.html_body},
            "toRecipients": [{"emailAddress": e.dict()} for e in body.to],
        },
        "saveToSentItems": "true",
    }
    result = graph_app_request("POST", f"/users/{body.from_user_id}/sendMail", json_body=payload)
    return {"ok": True, "result": result}

@app.post("/events")
def create_event(body: CreateEventBody):
    """
    App-only: create event on a user's calendar (requires Calendars.ReadWrite application permission).
    """
    attendees = [
        {"emailAddress": {"address": a.address, "name": a.name or a.address}, "type": "required"}
        for a in body.attendees
    ]
    payload = {
        "subject": body.subject,
        "body": {"contentType": "HTML", "content": body.body_html or ""},
        "start": {"dateTime": body.start_iso, "timeZone": body.timezone},
        "end": {"dateTime": body.end_iso, "timeZone": body.timezone},
        "attendees": attendees,
        "isOnlineMeeting": bool(body.is_online_meeting),
        "onlineMeetingProvider": "teamsForBusiness",
    }
    created = graph_app_request("POST", f"/users/{body.user_id}/events", json_body=payload)
    ev_id = created.get("id")
    if ev_id:
        created = graph_app_request(
            "GET",
            f"/users/{body.user_id}/events/{ev_id}",
            params={"$expand": "onlineMeeting", "$select": "id,subject,onlineMeeting"}
        )
    return {"ok": True, "event": created}

@app.post("/online-meetings")
def create_online_meeting(body: OnlineMeetingBody):
    """
    App-only: create an online meeting on behalf of a user (requires OnlineMeetings.ReadWrite.All application permission).
    """
    payload = {"subject": body.subject, "startDateTime": body.start_iso, "endDateTime": body.end_iso}
    r = graph_app_request("POST", f"/users/{body.user_id}/onlineMeetings", json_body=payload)
    return {"ok": True, "onlineMeeting": r}

@app.post("/teams/channels/message")
def post_channel_message(body: PostChannelMessageBody):
    """
    App-only channel post; requires:
      - RSC permission ChannelMessage.Send.Group
      - Your Teams app (with that RSC) installed in the target team
    """
    payload = {"body": {"contentType": "html", "content": body.content}}
    r = graph_app_request("POST", f"/teams/{body.team_id}/channels/{body.channel_id}/messages", json_body=payload)
    return {"ok": True, "message": r}

@app.get("/teams")
def list_teams(top: int = 50):
    r = graph_app_request(
        "GET",
        "/groups",
        params={"$filter": "resourceProvisioningOptions/Any(x:x eq 'Team')", "$select": "id,displayName", "$top": top},
    )
    return {"ok": True, "teams": r.get("value", [])}

@app.get("/teams/{team_id}/channels")
def list_channels(team_id: str, top: int = 50):
    r = graph_app_request("GET", f"/teams/{team_id}/channels", params={"$select": "id,displayName,description", "$top": top})
    return {"ok": True, "channels": r.get("value", [])}

@app.get("/users/{user_id}/events")
def list_calendar_events(user_id: str, start: str, end: str, online_only: bool = True, top: int = 50):
    filt = f"start/dateTime ge '{start}' and end/dateTime le '{end}'"
    if online_only:
        filt = f"isOnlineMeeting eq true and {filt}"
    r = graph_app_request(
        "GET",
        f"/users/{user_id}/events",
        params={"$filter": filt, "$expand": "onlineMeeting", "$select": "id,subject,start,end,onlineMeeting", "$top": top},
    )
    return {"ok": True, "events": r.get("value", [])}
